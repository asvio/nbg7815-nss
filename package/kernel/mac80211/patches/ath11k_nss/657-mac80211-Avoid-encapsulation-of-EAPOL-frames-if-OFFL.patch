From f2c96599c02eb0d47602d000fe0f40358c10c892 Mon Sep 17 00:00:00 2001
From: Aaradhana Sahu <quic_aarasahu@quicinc.com>
Date: Fri, 26 Aug 2022 17:54:37 +0530
Subject: [PATCH] mac80211: Avoid encapsulation of EAPOL frames if OFFLOAD_ENCAP is enabled

EAP Frames over NL80211 Control port are 802.11 Native WiFi
encapsulated by default, but for a vdev operating in 802.3, when FW doesnâ€™t
advertise WMI_SERVICE_EAPOL_OVER_NWIFI, it cannot accept an 802.11
Native WiFi frame.

Allow EAP Frames over NL80211 Control port to be passed as 802.3
if vif has IEEE80211_OFFLOAD_ENCAP_ENABLED set.

Signed-off-by: Rameshkumar Sundaram <quic_ramess@quicinc.com>
Signed-off-by: Aaradhana Sahu <quic_aarasahu@quicinc.com>
---
 net/mac80211/ieee80211_i.h |  5 ++++
 net/mac80211/tx.c          | 58 ++++++++++++++++++++++++++------------
 2 files changed, 45 insertions(+), 18 deletions(-)

--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -2062,6 +2062,11 @@ netdev_tx_t ieee80211_subif_start_xmit(s
 				       struct net_device *dev);
 netdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,
 					    struct net_device *dev);
+netdev_tx_t __ieee80211_subif_start_xmit_8023(struct sk_buff *skb,
+					      struct net_device *dev,
+					      u32 info_flags,
+					      u32 ctrl_flags,
+					      u64 *cookie);
 void __ieee80211_subif_start_xmit(struct sk_buff *skb,
 				  struct net_device *dev,
 				  u32 info_flags,
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -39,7 +39,8 @@
 
 static void ieee80211_8023_xmit(struct ieee80211_sub_if_data *sdata,
 				struct net_device *dev, struct sta_info *sta,
-				struct ieee80211_key *key, struct sk_buff *skb);
+				struct ieee80211_key *key, struct sk_buff *skb,
+				u32 info_flags, u32 ctrl_flags, u64 *cookie);
 
 static inline void ieee80211_tx_stats(struct net_device *dev, u32 len)
 {
@@ -4310,13 +4311,18 @@ void __ieee80211_subif_start_xmit(struct
 		atomic_inc(&sta->tx_netif_pkts);
 
         if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {
-                ap_sdata = container_of(sdata->bss,
-                                        struct ieee80211_sub_if_data, u.ap);
+                if (!ieee80211_hw_check(&local->hw, SUPPORTS_NSS_OFFLOAD))
+                        ap_sdata = container_of(sdata->bss,
+                                                struct ieee80211_sub_if_data,
+                                                u.ap);
+                else
+                        ap_sdata = sdata;
+
                 if (ap_sdata->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED &&
                     !is_multicast_ether_addr(skb->data)) {
                         if (sta)
                                 key = rcu_dereference(sta->ptk[sta->ptk_idx]);
-                        ieee80211_8023_xmit(sdata, dev, sta, key, skb);
+                        ieee80211_8023_xmit(sdata, dev, sta, key, skb, info_flags, ctrl_flags, cookie);
                         rcu_read_unlock();
                         return;
                 }
@@ -4657,19 +4663,29 @@ static bool ieee80211_tx_8023(struct iee
 
 static void ieee80211_8023_xmit(struct ieee80211_sub_if_data *sdata,
 				struct net_device *dev, struct sta_info *sta,
-				struct ieee80211_key *key, struct sk_buff *skb)
+				struct ieee80211_key *key, struct sk_buff *skb,
+				u32 info_flags, u32 ctrl_flags, u64 *cookie)
 {
 	struct ieee80211_tx_info *info;
+	struct ethhdr *ehdr = (struct ethhdr *)skb->data;
 	struct ieee80211_local *local = sdata->local;
 	struct tid_ampdu_tx *tid_tx;
 	struct sk_buff *seg, *next;
 	unsigned int skbs = 0, len = 0;
 	u16 queue;
+	unsigned char *ra = ehdr->h_dest;
+	bool multicast;
 	u8 tid;
 
 	queue = ieee80211_select_queue(sdata, sta, skb);
 	skb_set_queue_mapping(skb, queue);
 
+	multicast = is_multicast_ether_addr(ra);
+
+	if (multicast && sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
+	    !atomic_read(&sdata->u.vlan.num_mcast_sta))
+		goto out_free;
+
 	if (unlikely(test_bit(SCAN_SW_SCANNING, &local->scanning)) &&
 	    test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))
 		goto out_free;
@@ -4704,6 +4720,7 @@ static void ieee80211_8023_xmit(struct i
 	info = IEEE80211_SKB_CB(skb);
 	memset(info, 0, sizeof(*info));
 
+	info->flags |= info_flags;
 	info->hw_queue = sdata->vif.hw_queue[queue];
 
 	if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
@@ -4723,9 +4740,10 @@ static void ieee80211_8023_xmit(struct i
 			memcpy(IEEE80211_SKB_CB(seg), info, sizeof(*info));
 	}
 
-	if (unlikely(skb->sk &&
-		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS &&
-		     !ieee80211_hw_check(&local->hw, SUPPORTS_NSS_OFFLOAD) && sta))
+	if (unlikely(((skb->sk &&
+		       skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS) ||
+		      ((ctrl_flags & IEEE80211_TX_CTL_REQ_TX_STATUS) && !multicast)) &&
+		     !ieee80211_hw_check(&local->hw, SUPPORTS_NSS_OFFLOAD)))
 		info->ack_frame_id = ieee80211_store_ack_skb(local, skb,
 							     &info->flags, NULL);
 
@@ -4750,7 +4768,8 @@ out_free:
 
 void ieee80211_8023_xmit_ap(struct ieee80211_sub_if_data *sdata,
 			    struct net_device *dev, struct sta_info *sta,
-			    struct ieee80211_key *key, struct sk_buff *skb)
+			    struct ieee80211_key *key, struct sk_buff *skb,
+			    u32 info_flags, u32 ctrl_flags, u64 *cookie)
 {
 	struct ieee80211_tx_info *info;
 	struct ieee80211_local *local = sdata->local;
@@ -4759,6 +4778,9 @@ void ieee80211_8023_xmit_ap(struct ieee8
 	unsigned long flags;
 	int q;
 	u16 q_map;
+	struct ethhdr *ehdr = (struct ethhdr *)skb->data;
+	unsigned char *ra = ehdr->h_dest;
+	bool multicast = is_multicast_ether_addr(ra);
 
 	/*
 	 * If the skb is shared we need to obtain our own copy.
@@ -4770,11 +4792,13 @@ void ieee80211_8023_xmit_ap(struct ieee8
 
 	info = IEEE80211_SKB_CB(skb);
 	memset(info, 0, sizeof(*info));
+	info->flags |= info_flags;
 
-	if (unlikely(skb->sk &&
-		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))
+	if (unlikely((skb->sk &&
+		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS) ||
+		     ((ctrl_flags & IEEE80211_TX_CTL_REQ_TX_STATUS) && !multicast)))
 		info->ack_frame_id = ieee80211_store_ack_skb(local, skb,
-							     &info->flags, NULL);
+							     &info->flags, cookie);
 
 	info->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;
 	info->control.vif = &sdata->vif;
@@ -4811,14 +4835,23 @@ void ieee80211_8023_xmit_ap(struct ieee8
 	if (sta)
 		atomic_inc(&sta->tx_drv_pkts);
 }
-
 netdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,
 					    struct net_device *dev)
 {
+	return __ieee80211_subif_start_xmit_8023(skb, dev, 0, 0, NULL);
+}
+
+netdev_tx_t __ieee80211_subif_start_xmit_8023(struct sk_buff *skb,
+					      struct net_device *dev,
+					      u32 info_flags,
+					      u32 ctrl_flags,
+					      u64 *cookie)
+{
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 	struct ethhdr *ehdr = (struct ethhdr *)skb->data;
 	struct ieee80211_key *key = NULL;
 	struct sta_info *sta;
+	bool is_eapol;
 
 #ifdef CPTCFG_MAC80211_NSS_SUPPORT
        ieee80211_xmit_nss_fixup(skb, dev);
@@ -4834,14 +4867,15 @@ netdev_tx_t ieee80211_subif_start_xmit_8
 		kfree_skb(skb);
 		goto out;
 	}
+	is_eapol = (sdata->control_port_protocol == ehdr->h_proto);
 
 	if (ieee80211_hw_check(&sdata->local->hw, SUPPORTS_NSS_OFFLOAD)) {
 		if (unlikely(IS_ERR_OR_NULL(sta) || !sta->uploaded))
 			sta = NULL;
 		goto tx_offload;
 	} else if (unlikely(IS_ERR_OR_NULL(sta) || !sta->uploaded ||
-		   !test_sta_flag(sta, WLAN_STA_AUTHORIZED) ||
-		   sdata->control_port_protocol == ehdr->h_proto))
+		(!test_sta_flag(sta, WLAN_STA_AUTHORIZED) && !is_eapol) ||
+		(is_eapol && !(sdata->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED))))
 		goto skip_offload;
 
 	key = rcu_dereference(sta->ptk[sta->ptk_idx]);
@@ -4852,13 +4886,13 @@ netdev_tx_t ieee80211_subif_start_xmit_8
 		goto skip_offload;
 
 	if (sdata->vif.type == NL80211_IFTYPE_AP) {
-		ieee80211_8023_xmit_ap(sdata, dev, sta, key, skb);
+		ieee80211_8023_xmit_ap(sdata, dev, sta, key, skb, info_flags, ctrl_flags, cookie);
 		goto out;
 	}
 
 	sk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);
 tx_offload:
-	ieee80211_8023_xmit(sdata, dev, sta, key, skb);
+	ieee80211_8023_xmit(sdata, dev, sta, key, skb, info_flags, ctrl_flags, cookie);
 	goto out;
 
 skip_offload:
@@ -6364,13 +6398,10 @@ start_xmit:
 	mutex_lock(&local->mtx);
 
 	local_bh_disable();
-
-	/* added hardware encap check for ethernet mode */
 	if (sdata->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
-		ieee80211_subif_start_xmit_8023(skb, skb->dev);
+		__ieee80211_subif_start_xmit_8023(skb, skb->dev, flags, ctrl_flags, cookie);
 	else
 		__ieee80211_subif_start_xmit(skb, skb->dev, flags, ctrl_flags, cookie);
-
 	local_bh_enable();
 
 	mutex_unlock(&local->mtx);
